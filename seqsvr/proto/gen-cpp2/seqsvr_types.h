/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>

#include <thrift/lib/cpp2/GeneratedHeaderHelper.h>



namespace seqsvr {

class NodeAddrInfo;
class RangeID;
class RouterNode;
class Router;
class SetNodeInfo;
class SetNodeInfoList;
class PerSetRouterTable;
class Sequence;
class MaxSeqsData;

class NodeAddrInfo : private apache::thrift::detail::st::ComparisonOperators<NodeAddrInfo> {
 public:

  NodeAddrInfo() :
      port(0) {}
  // FragileConstructor for use in initialization lists only

  NodeAddrInfo(apache::thrift::FragileConstructor, std::string ip__arg, int32_t port__arg) :
      ip(std::move(ip__arg)),
      port(std::move(port__arg)) {
    __isset.ip = true;
    __isset.port = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  NodeAddrInfo(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    NodeAddrInfo(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    ip = arg.move();
    __isset.ip = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  NodeAddrInfo(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    NodeAddrInfo(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    port = arg.move();
    __isset.port = true;
  }

  NodeAddrInfo(NodeAddrInfo&&) = default;

  NodeAddrInfo(const NodeAddrInfo&) = default;

  NodeAddrInfo& operator=(NodeAddrInfo&&) = default;

  NodeAddrInfo& operator=(const NodeAddrInfo&) = default;
  void __clear();

  virtual ~NodeAddrInfo() {}

  std::string ip;
  int32_t port;

  struct __isset {
    void __clear() {
      ip = false;
      port = false;
    }

    bool ip = false;
    bool port = false;
  } __isset;
  bool operator==(const NodeAddrInfo& rhs) const;

  bool operator < (const NodeAddrInfo& rhs) const {
    if (!(ip == rhs.ip)) {
      return ip < rhs.ip;
    }
    if (!(port == rhs.port)) {
      return port < rhs.port;
    }
    (void)rhs;
    return false;
  }

  const std::string& get_ip() const& {
    return ip;
  }

  std::string get_ip() && {
    return std::move(ip);
  }

  template <typename T_NodeAddrInfo_ip_struct_setter>
  std::string& set_ip(T_NodeAddrInfo_ip_struct_setter&& ip_) {
    ip = std::forward<T_NodeAddrInfo_ip_struct_setter>(ip_);
    __isset.ip = true;
    return ip;
  }

  int32_t get_port() const {
    return port;
  }

  int32_t& set_port(int32_t port_) {
    port = port_;
    __isset.port = true;
    return port;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(NodeAddrInfo& a, NodeAddrInfo& b);
extern template uint32_t NodeAddrInfo::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t NodeAddrInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t NodeAddrInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t NodeAddrInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t NodeAddrInfo::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t NodeAddrInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t NodeAddrInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t NodeAddrInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t NodeAddrInfo::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t NodeAddrInfo::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t NodeAddrInfo::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t NodeAddrInfo::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::NodeAddrInfo>::clear( ::seqsvr::NodeAddrInfo* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::NodeAddrInfo>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::NodeAddrInfo>::write(Protocol* proto,  ::seqsvr::NodeAddrInfo const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::NodeAddrInfo>::read(Protocol* proto,  ::seqsvr::NodeAddrInfo* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::NodeAddrInfo>::serializedSize(Protocol const* proto,  ::seqsvr::NodeAddrInfo const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::NodeAddrInfo>::serializedSizeZC(Protocol const* proto,  ::seqsvr::NodeAddrInfo const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

class RangeID : private apache::thrift::detail::st::ComparisonOperators<RangeID> {
 public:

  RangeID() :
      id_begin(0),
      size(0) {}
  // FragileConstructor for use in initialization lists only

  RangeID(apache::thrift::FragileConstructor, int32_t id_begin__arg, int32_t size__arg) :
      id_begin(std::move(id_begin__arg)),
      size(std::move(size__arg)) {
    __isset.id_begin = true;
    __isset.size = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  RangeID(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    RangeID(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id_begin = arg.move();
    __isset.id_begin = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  RangeID(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    RangeID(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    size = arg.move();
    __isset.size = true;
  }

  RangeID(RangeID&&) = default;

  RangeID(const RangeID&) = default;

  RangeID& operator=(RangeID&&) = default;

  RangeID& operator=(const RangeID&) = default;
  void __clear();

  virtual ~RangeID() {}

  int32_t id_begin;
  int32_t size;

  struct __isset {
    void __clear() {
      id_begin = false;
      size = false;
    }

    bool id_begin = false;
    bool size = false;
  } __isset;
  bool operator==(const RangeID& rhs) const;

  bool operator < (const RangeID& rhs) const {
    if (!(id_begin == rhs.id_begin)) {
      return id_begin < rhs.id_begin;
    }
    if (!(size == rhs.size)) {
      return size < rhs.size;
    }
    (void)rhs;
    return false;
  }

  int32_t get_id_begin() const {
    return id_begin;
  }

  int32_t& set_id_begin(int32_t id_begin_) {
    id_begin = id_begin_;
    __isset.id_begin = true;
    return id_begin;
  }

  int32_t get_size() const {
    return size;
  }

  int32_t& set_size(int32_t size_) {
    size = size_;
    __isset.size = true;
    return size;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(RangeID& a, RangeID& b);
extern template uint32_t RangeID::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t RangeID::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t RangeID::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t RangeID::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t RangeID::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t RangeID::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t RangeID::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t RangeID::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t RangeID::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t RangeID::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t RangeID::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t RangeID::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::RangeID>::clear( ::seqsvr::RangeID* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::RangeID>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::RangeID>::write(Protocol* proto,  ::seqsvr::RangeID const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::RangeID>::read(Protocol* proto,  ::seqsvr::RangeID* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::RangeID>::serializedSize(Protocol const* proto,  ::seqsvr::RangeID const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::RangeID>::serializedSizeZC(Protocol const* proto,  ::seqsvr::RangeID const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

class RouterNode : private apache::thrift::detail::st::ComparisonOperators<RouterNode> {
 public:

  RouterNode() {}
  // FragileConstructor for use in initialization lists only

  RouterNode(apache::thrift::FragileConstructor,  ::seqsvr::NodeAddrInfo node_addr__arg, std::vector< ::seqsvr::RangeID> section_ranges__arg) :
      node_addr(std::move(node_addr__arg)),
      section_ranges(std::move(section_ranges__arg)) {
    __isset.node_addr = true;
    __isset.section_ranges = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  RouterNode(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    RouterNode(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    node_addr = arg.move();
    __isset.node_addr = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  RouterNode(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    RouterNode(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    section_ranges = arg.move();
    __isset.section_ranges = true;
  }

  RouterNode(RouterNode&&) = default;

  RouterNode(const RouterNode&) = default;

  RouterNode& operator=(RouterNode&&) = default;

  RouterNode& operator=(const RouterNode&) = default;
  void __clear();

  virtual ~RouterNode() {}

   ::seqsvr::NodeAddrInfo node_addr;
  std::vector< ::seqsvr::RangeID> section_ranges;

  struct __isset {
    void __clear() {
      node_addr = false;
      section_ranges = false;
    }

    bool node_addr = false;
    bool section_ranges = false;
  } __isset;
  bool operator==(const RouterNode& rhs) const;

  bool operator < (const RouterNode& rhs) const {
    if (!(node_addr == rhs.node_addr)) {
      return node_addr < rhs.node_addr;
    }
    if (!(section_ranges == rhs.section_ranges)) {
      return section_ranges < rhs.section_ranges;
    }
    (void)rhs;
    return false;
  }
  const  ::seqsvr::NodeAddrInfo& get_node_addr() const&;
   ::seqsvr::NodeAddrInfo get_node_addr() &&;

  template <typename T_RouterNode_node_addr_struct_setter>
   ::seqsvr::NodeAddrInfo& set_node_addr(T_RouterNode_node_addr_struct_setter&& node_addr_) {
    node_addr = std::forward<T_RouterNode_node_addr_struct_setter>(node_addr_);
    __isset.node_addr = true;
    return node_addr;
  }
  const std::vector< ::seqsvr::RangeID>& get_section_ranges() const&;
  std::vector< ::seqsvr::RangeID> get_section_ranges() &&;

  template <typename T_RouterNode_section_ranges_struct_setter>
  std::vector< ::seqsvr::RangeID>& set_section_ranges(T_RouterNode_section_ranges_struct_setter&& section_ranges_) {
    section_ranges = std::forward<T_RouterNode_section_ranges_struct_setter>(section_ranges_);
    __isset.section_ranges = true;
    return section_ranges;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(RouterNode& a, RouterNode& b);
extern template uint32_t RouterNode::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t RouterNode::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t RouterNode::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t RouterNode::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t RouterNode::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t RouterNode::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t RouterNode::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t RouterNode::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t RouterNode::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t RouterNode::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t RouterNode::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t RouterNode::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::RouterNode>::clear( ::seqsvr::RouterNode* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::RouterNode>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::RouterNode>::write(Protocol* proto,  ::seqsvr::RouterNode const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::RouterNode>::read(Protocol* proto,  ::seqsvr::RouterNode* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::RouterNode>::serializedSize(Protocol const* proto,  ::seqsvr::RouterNode const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::RouterNode>::serializedSizeZC(Protocol const* proto,  ::seqsvr::RouterNode const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

class Router : private apache::thrift::detail::st::ComparisonOperators<Router> {
 public:

  Router() :
      version(0) {}
  // FragileConstructor for use in initialization lists only

  Router(apache::thrift::FragileConstructor, int32_t version__arg, std::vector< ::seqsvr::RouterNode> node_list__arg) :
      version(std::move(version__arg)),
      node_list(std::move(node_list__arg)) {
    __isset.version = true;
    __isset.node_list = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Router(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Router(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    version = arg.move();
    __isset.version = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Router(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Router(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    node_list = arg.move();
    __isset.node_list = true;
  }

  Router(Router&&) = default;

  Router(const Router&) = default;

  Router& operator=(Router&&) = default;

  Router& operator=(const Router&) = default;
  void __clear();

  virtual ~Router() {}

  int32_t version;
  std::vector< ::seqsvr::RouterNode> node_list;

  struct __isset {
    void __clear() {
      version = false;
      node_list = false;
    }

    bool version = false;
    bool node_list = false;
  } __isset;
  bool operator==(const Router& rhs) const;

  bool operator < (const Router& rhs) const {
    if (!(version == rhs.version)) {
      return version < rhs.version;
    }
    if (!(node_list == rhs.node_list)) {
      return node_list < rhs.node_list;
    }
    (void)rhs;
    return false;
  }

  int32_t get_version() const {
    return version;
  }

  int32_t& set_version(int32_t version_) {
    version = version_;
    __isset.version = true;
    return version;
  }
  const std::vector< ::seqsvr::RouterNode>& get_node_list() const&;
  std::vector< ::seqsvr::RouterNode> get_node_list() &&;

  template <typename T_Router_node_list_struct_setter>
  std::vector< ::seqsvr::RouterNode>& set_node_list(T_Router_node_list_struct_setter&& node_list_) {
    node_list = std::forward<T_Router_node_list_struct_setter>(node_list_);
    __isset.node_list = true;
    return node_list;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(Router& a, Router& b);
extern template uint32_t Router::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t Router::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t Router::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Router::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Router::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t Router::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t Router::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Router::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Router::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t Router::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t Router::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t Router::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::Router>::clear( ::seqsvr::Router* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::Router>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::Router>::write(Protocol* proto,  ::seqsvr::Router const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::Router>::read(Protocol* proto,  ::seqsvr::Router* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::Router>::serializedSize(Protocol const* proto,  ::seqsvr::Router const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::Router>::serializedSizeZC(Protocol const* proto,  ::seqsvr::Router const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

class SetNodeInfo : private apache::thrift::detail::st::ComparisonOperators<SetNodeInfo> {
 public:

  SetNodeInfo() {}
  // FragileConstructor for use in initialization lists only

  SetNodeInfo(apache::thrift::FragileConstructor,  ::seqsvr::RangeID set_id__arg,  ::seqsvr::NodeAddrInfo node_addr__arg) :
      set_id(std::move(set_id__arg)),
      node_addr(std::move(node_addr__arg)) {
    __isset.set_id = true;
    __isset.node_addr = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  SetNodeInfo(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    SetNodeInfo(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    set_id = arg.move();
    __isset.set_id = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  SetNodeInfo(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    SetNodeInfo(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    node_addr = arg.move();
    __isset.node_addr = true;
  }

  SetNodeInfo(SetNodeInfo&&) = default;

  SetNodeInfo(const SetNodeInfo&) = default;

  SetNodeInfo& operator=(SetNodeInfo&&) = default;

  SetNodeInfo& operator=(const SetNodeInfo&) = default;
  void __clear();

  virtual ~SetNodeInfo() {}

   ::seqsvr::RangeID set_id;
   ::seqsvr::NodeAddrInfo node_addr;

  struct __isset {
    void __clear() {
      set_id = false;
      node_addr = false;
    }

    bool set_id = false;
    bool node_addr = false;
  } __isset;
  bool operator==(const SetNodeInfo& rhs) const;

  bool operator < (const SetNodeInfo& rhs) const {
    if (!(set_id == rhs.set_id)) {
      return set_id < rhs.set_id;
    }
    if (!(node_addr == rhs.node_addr)) {
      return node_addr < rhs.node_addr;
    }
    (void)rhs;
    return false;
  }
  const  ::seqsvr::RangeID& get_set_id() const&;
   ::seqsvr::RangeID get_set_id() &&;

  template <typename T_SetNodeInfo_set_id_struct_setter>
   ::seqsvr::RangeID& set_set_id(T_SetNodeInfo_set_id_struct_setter&& set_id_) {
    set_id = std::forward<T_SetNodeInfo_set_id_struct_setter>(set_id_);
    __isset.set_id = true;
    return set_id;
  }
  const  ::seqsvr::NodeAddrInfo& get_node_addr() const&;
   ::seqsvr::NodeAddrInfo get_node_addr() &&;

  template <typename T_SetNodeInfo_node_addr_struct_setter>
   ::seqsvr::NodeAddrInfo& set_node_addr(T_SetNodeInfo_node_addr_struct_setter&& node_addr_) {
    node_addr = std::forward<T_SetNodeInfo_node_addr_struct_setter>(node_addr_);
    __isset.node_addr = true;
    return node_addr;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(SetNodeInfo& a, SetNodeInfo& b);
extern template uint32_t SetNodeInfo::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t SetNodeInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t SetNodeInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t SetNodeInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t SetNodeInfo::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t SetNodeInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t SetNodeInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t SetNodeInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t SetNodeInfo::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t SetNodeInfo::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t SetNodeInfo::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t SetNodeInfo::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::SetNodeInfo>::clear( ::seqsvr::SetNodeInfo* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::SetNodeInfo>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::SetNodeInfo>::write(Protocol* proto,  ::seqsvr::SetNodeInfo const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::SetNodeInfo>::read(Protocol* proto,  ::seqsvr::SetNodeInfo* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::SetNodeInfo>::serializedSize(Protocol const* proto,  ::seqsvr::SetNodeInfo const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::SetNodeInfo>::serializedSizeZC(Protocol const* proto,  ::seqsvr::SetNodeInfo const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

class SetNodeInfoList : private apache::thrift::detail::st::ComparisonOperators<SetNodeInfoList> {
 public:

  SetNodeInfoList() {}
  // FragileConstructor for use in initialization lists only

  SetNodeInfoList(apache::thrift::FragileConstructor,  ::seqsvr::RangeID set_id__arg, std::vector< ::seqsvr::NodeAddrInfo> node_addrs__arg) :
      set_id(std::move(set_id__arg)),
      node_addrs(std::move(node_addrs__arg)) {
    __isset.set_id = true;
    __isset.node_addrs = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  SetNodeInfoList(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    SetNodeInfoList(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    set_id = arg.move();
    __isset.set_id = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  SetNodeInfoList(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    SetNodeInfoList(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    node_addrs = arg.move();
    __isset.node_addrs = true;
  }

  SetNodeInfoList(SetNodeInfoList&&) = default;

  SetNodeInfoList(const SetNodeInfoList&) = default;

  SetNodeInfoList& operator=(SetNodeInfoList&&) = default;

  SetNodeInfoList& operator=(const SetNodeInfoList&) = default;
  void __clear();

  virtual ~SetNodeInfoList() {}

   ::seqsvr::RangeID set_id;
  std::vector< ::seqsvr::NodeAddrInfo> node_addrs;

  struct __isset {
    void __clear() {
      set_id = false;
      node_addrs = false;
    }

    bool set_id = false;
    bool node_addrs = false;
  } __isset;
  bool operator==(const SetNodeInfoList& rhs) const;

  bool operator < (const SetNodeInfoList& rhs) const {
    if (!(set_id == rhs.set_id)) {
      return set_id < rhs.set_id;
    }
    if (!(node_addrs == rhs.node_addrs)) {
      return node_addrs < rhs.node_addrs;
    }
    (void)rhs;
    return false;
  }
  const  ::seqsvr::RangeID& get_set_id() const&;
   ::seqsvr::RangeID get_set_id() &&;

  template <typename T_SetNodeInfoList_set_id_struct_setter>
   ::seqsvr::RangeID& set_set_id(T_SetNodeInfoList_set_id_struct_setter&& set_id_) {
    set_id = std::forward<T_SetNodeInfoList_set_id_struct_setter>(set_id_);
    __isset.set_id = true;
    return set_id;
  }
  const std::vector< ::seqsvr::NodeAddrInfo>& get_node_addrs() const&;
  std::vector< ::seqsvr::NodeAddrInfo> get_node_addrs() &&;

  template <typename T_SetNodeInfoList_node_addrs_struct_setter>
  std::vector< ::seqsvr::NodeAddrInfo>& set_node_addrs(T_SetNodeInfoList_node_addrs_struct_setter&& node_addrs_) {
    node_addrs = std::forward<T_SetNodeInfoList_node_addrs_struct_setter>(node_addrs_);
    __isset.node_addrs = true;
    return node_addrs;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(SetNodeInfoList& a, SetNodeInfoList& b);
extern template uint32_t SetNodeInfoList::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t SetNodeInfoList::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t SetNodeInfoList::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t SetNodeInfoList::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t SetNodeInfoList::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t SetNodeInfoList::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t SetNodeInfoList::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t SetNodeInfoList::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t SetNodeInfoList::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t SetNodeInfoList::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t SetNodeInfoList::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t SetNodeInfoList::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::SetNodeInfoList>::clear( ::seqsvr::SetNodeInfoList* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::SetNodeInfoList>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::SetNodeInfoList>::write(Protocol* proto,  ::seqsvr::SetNodeInfoList const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::SetNodeInfoList>::read(Protocol* proto,  ::seqsvr::SetNodeInfoList* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::SetNodeInfoList>::serializedSize(Protocol const* proto,  ::seqsvr::SetNodeInfoList const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::SetNodeInfoList>::serializedSizeZC(Protocol const* proto,  ::seqsvr::SetNodeInfoList const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

class PerSetRouterTable : private apache::thrift::detail::st::ComparisonOperators<PerSetRouterTable> {
 public:

  PerSetRouterTable() {}
  // FragileConstructor for use in initialization lists only

  PerSetRouterTable(apache::thrift::FragileConstructor,  ::seqsvr::RangeID set_id__arg, std::vector< ::seqsvr::RouterNode> node_list__arg) :
      set_id(std::move(set_id__arg)),
      node_list(std::move(node_list__arg)) {
    __isset.set_id = true;
    __isset.node_list = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  PerSetRouterTable(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    PerSetRouterTable(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    set_id = arg.move();
    __isset.set_id = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  PerSetRouterTable(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    PerSetRouterTable(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    node_list = arg.move();
    __isset.node_list = true;
  }

  PerSetRouterTable(PerSetRouterTable&&) = default;

  PerSetRouterTable(const PerSetRouterTable&) = default;

  PerSetRouterTable& operator=(PerSetRouterTable&&) = default;

  PerSetRouterTable& operator=(const PerSetRouterTable&) = default;
  void __clear();

  virtual ~PerSetRouterTable() {}

   ::seqsvr::RangeID set_id;
  std::vector< ::seqsvr::RouterNode> node_list;

  struct __isset {
    void __clear() {
      set_id = false;
      node_list = false;
    }

    bool set_id = false;
    bool node_list = false;
  } __isset;
  bool operator==(const PerSetRouterTable& rhs) const;

  bool operator < (const PerSetRouterTable& rhs) const {
    if (!(set_id == rhs.set_id)) {
      return set_id < rhs.set_id;
    }
    if (!(node_list == rhs.node_list)) {
      return node_list < rhs.node_list;
    }
    (void)rhs;
    return false;
  }
  const  ::seqsvr::RangeID& get_set_id() const&;
   ::seqsvr::RangeID get_set_id() &&;

  template <typename T_PerSetRouterTable_set_id_struct_setter>
   ::seqsvr::RangeID& set_set_id(T_PerSetRouterTable_set_id_struct_setter&& set_id_) {
    set_id = std::forward<T_PerSetRouterTable_set_id_struct_setter>(set_id_);
    __isset.set_id = true;
    return set_id;
  }
  const std::vector< ::seqsvr::RouterNode>& get_node_list() const&;
  std::vector< ::seqsvr::RouterNode> get_node_list() &&;

  template <typename T_PerSetRouterTable_node_list_struct_setter>
  std::vector< ::seqsvr::RouterNode>& set_node_list(T_PerSetRouterTable_node_list_struct_setter&& node_list_) {
    node_list = std::forward<T_PerSetRouterTable_node_list_struct_setter>(node_list_);
    __isset.node_list = true;
    return node_list;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(PerSetRouterTable& a, PerSetRouterTable& b);
extern template uint32_t PerSetRouterTable::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t PerSetRouterTable::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t PerSetRouterTable::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t PerSetRouterTable::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t PerSetRouterTable::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t PerSetRouterTable::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t PerSetRouterTable::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t PerSetRouterTable::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t PerSetRouterTable::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t PerSetRouterTable::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t PerSetRouterTable::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t PerSetRouterTable::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::PerSetRouterTable>::clear( ::seqsvr::PerSetRouterTable* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::PerSetRouterTable>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::PerSetRouterTable>::write(Protocol* proto,  ::seqsvr::PerSetRouterTable const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::PerSetRouterTable>::read(Protocol* proto,  ::seqsvr::PerSetRouterTable* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::PerSetRouterTable>::serializedSize(Protocol const* proto,  ::seqsvr::PerSetRouterTable const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::PerSetRouterTable>::serializedSizeZC(Protocol const* proto,  ::seqsvr::PerSetRouterTable const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

class Sequence : private apache::thrift::detail::st::ComparisonOperators<Sequence> {
 public:

  Sequence() :
      sequence(0) {}
  // FragileConstructor for use in initialization lists only

  Sequence(apache::thrift::FragileConstructor, int64_t sequence__arg,  ::seqsvr::Router router__arg) :
      sequence(std::move(sequence__arg)),
      router(std::move(router__arg)) {
    __isset.sequence = true;
    __isset.router = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Sequence(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Sequence(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    sequence = arg.move();
    __isset.sequence = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Sequence(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Sequence(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    router = arg.move();
    __isset.router = true;
  }

  Sequence(Sequence&&) = default;

  Sequence(const Sequence&) = default;

  Sequence& operator=(Sequence&&) = default;

  Sequence& operator=(const Sequence&) = default;
  void __clear();

  virtual ~Sequence() {}

  int64_t sequence;
   ::seqsvr::Router router;

  struct __isset {
    void __clear() {
      sequence = false;
      router = false;
    }

    bool sequence = false;
    bool router = false;
  } __isset;
  bool operator==(const Sequence& rhs) const;
  bool operator < (const Sequence& rhs) const;

  int64_t get_sequence() const {
    return sequence;
  }

  int64_t& set_sequence(int64_t sequence_) {
    sequence = sequence_;
    __isset.sequence = true;
    return sequence;
  }
  const  ::seqsvr::Router* get_router() const&;
   ::seqsvr::Router* get_router() &;
   ::seqsvr::Router* get_router() && = delete;

  template <typename T_Sequence_router_struct_setter>
   ::seqsvr::Router& set_router(T_Sequence_router_struct_setter&& router_) {
    router = std::forward<T_Sequence_router_struct_setter>(router_);
    __isset.router = true;
    return router;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(Sequence& a, Sequence& b);
extern template uint32_t Sequence::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t Sequence::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t Sequence::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Sequence::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Sequence::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t Sequence::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t Sequence::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Sequence::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Sequence::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t Sequence::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t Sequence::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t Sequence::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::Sequence>::clear( ::seqsvr::Sequence* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::Sequence>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::Sequence>::write(Protocol* proto,  ::seqsvr::Sequence const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::Sequence>::read(Protocol* proto,  ::seqsvr::Sequence* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::Sequence>::serializedSize(Protocol const* proto,  ::seqsvr::Sequence const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::Sequence>::serializedSizeZC(Protocol const* proto,  ::seqsvr::Sequence const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

class MaxSeqsData : private apache::thrift::detail::st::ComparisonOperators<MaxSeqsData> {
 public:

  MaxSeqsData() {}
  // FragileConstructor for use in initialization lists only

  MaxSeqsData(apache::thrift::FragileConstructor,  ::seqsvr::RangeID set_id__arg, std::vector<int64_t> max_seqs__arg) :
      set_id(std::move(set_id__arg)),
      max_seqs(std::move(max_seqs__arg)) {
    __isset.set_id = true;
    __isset.max_seqs = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  MaxSeqsData(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    MaxSeqsData(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    set_id = arg.move();
    __isset.set_id = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  MaxSeqsData(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    MaxSeqsData(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    max_seqs = arg.move();
    __isset.max_seqs = true;
  }

  MaxSeqsData(MaxSeqsData&&) = default;

  MaxSeqsData(const MaxSeqsData&) = default;

  MaxSeqsData& operator=(MaxSeqsData&&) = default;

  MaxSeqsData& operator=(const MaxSeqsData&) = default;
  void __clear();

  virtual ~MaxSeqsData() {}

   ::seqsvr::RangeID set_id;
  std::vector<int64_t> max_seqs;

  struct __isset {
    void __clear() {
      set_id = false;
      max_seqs = false;
    }

    bool set_id = false;
    bool max_seqs = false;
  } __isset;
  bool operator==(const MaxSeqsData& rhs) const;

  bool operator < (const MaxSeqsData& rhs) const {
    if (!(set_id == rhs.set_id)) {
      return set_id < rhs.set_id;
    }
    if (!(max_seqs == rhs.max_seqs)) {
      return max_seqs < rhs.max_seqs;
    }
    (void)rhs;
    return false;
  }
  const  ::seqsvr::RangeID& get_set_id() const&;
   ::seqsvr::RangeID get_set_id() &&;

  template <typename T_MaxSeqsData_set_id_struct_setter>
   ::seqsvr::RangeID& set_set_id(T_MaxSeqsData_set_id_struct_setter&& set_id_) {
    set_id = std::forward<T_MaxSeqsData_set_id_struct_setter>(set_id_);
    __isset.set_id = true;
    return set_id;
  }
  const std::vector<int64_t>& get_max_seqs() const&;
  std::vector<int64_t> get_max_seqs() &&;

  template <typename T_MaxSeqsData_max_seqs_struct_setter>
  std::vector<int64_t>& set_max_seqs(T_MaxSeqsData_max_seqs_struct_setter&& max_seqs_) {
    max_seqs = std::forward<T_MaxSeqsData_max_seqs_struct_setter>(max_seqs_);
    __isset.max_seqs = true;
    return max_seqs;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);
};

void swap(MaxSeqsData& a, MaxSeqsData& b);
extern template uint32_t MaxSeqsData::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t MaxSeqsData::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t MaxSeqsData::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t MaxSeqsData::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t MaxSeqsData::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t MaxSeqsData::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t MaxSeqsData::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t MaxSeqsData::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t MaxSeqsData::read<>(apache::thrift::SimpleJSONProtocolReader*);
extern template uint32_t MaxSeqsData::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
extern template uint32_t MaxSeqsData::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
extern template uint32_t MaxSeqsData::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

} // seqsvr
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::seqsvr::MaxSeqsData>::clear( ::seqsvr::MaxSeqsData* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::seqsvr::MaxSeqsData>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::MaxSeqsData>::write(Protocol* proto,  ::seqsvr::MaxSeqsData const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::MaxSeqsData>::read(Protocol* proto,  ::seqsvr::MaxSeqsData* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::MaxSeqsData>::serializedSize(Protocol const* proto,  ::seqsvr::MaxSeqsData const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::seqsvr::MaxSeqsData>::serializedSizeZC(Protocol const* proto,  ::seqsvr::MaxSeqsData const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace seqsvr {

} // seqsvr
