/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "StoreService.h"

#include "StoreService.tcc"

#include <thrift/lib/cpp2/protocol/BinaryProtocol.h>
#include <thrift/lib/cpp2/protocol/CompactProtocol.h>
#include <thrift/lib/cpp2/protocol/SimpleJSONProtocol.h>
namespace seqsvr {

const char* StoreServiceAsyncClient::getServiceName() {
  return "StoreService";
}

void StoreServiceAsyncClient::LoadMaxSeqsData(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  LoadMaxSeqsDataImpl(false, rpcOptions, std::move(callback));
}

void StoreServiceAsyncClient::LoadMaxSeqsData(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  LoadMaxSeqsDataImpl(false, rpcOptions, std::move(callback));
}

void StoreServiceAsyncClient::LoadMaxSeqsDataImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      LoadMaxSeqsDataT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      LoadMaxSeqsDataT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void StoreServiceAsyncClient::sync_LoadMaxSeqsData( ::seqsvr::MaxSeqsData& _return) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_LoadMaxSeqsData(rpcOptions, _return);
}

void StoreServiceAsyncClient::sync_LoadMaxSeqsData(apache::thrift::RpcOptions& rpcOptions,  ::seqsvr::MaxSeqsData& _return) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  LoadMaxSeqsDataImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_LoadMaxSeqsData(_return, _returnState);
}

folly::Future< ::seqsvr::MaxSeqsData> StoreServiceAsyncClient::future_LoadMaxSeqsData() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_LoadMaxSeqsData(rpcOptions);
}

folly::Future< ::seqsvr::MaxSeqsData> StoreServiceAsyncClient::future_LoadMaxSeqsData(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise< ::seqsvr::MaxSeqsData> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::seqsvr::MaxSeqsData>>(std::move(_promise), recv_wrapped_LoadMaxSeqsData, channel_);
  LoadMaxSeqsData(rpcOptions, std::move(callback));
  return _future;
}

folly::Future<std::pair< ::seqsvr::MaxSeqsData, std::unique_ptr<apache::thrift::transport::THeader>>> StoreServiceAsyncClient::header_future_LoadMaxSeqsData(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair< ::seqsvr::MaxSeqsData, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::seqsvr::MaxSeqsData>>(std::move(_promise), recv_wrapped_LoadMaxSeqsData, channel_);
  LoadMaxSeqsData(rpcOptions, std::move(callback));
  return _future;
}

void StoreServiceAsyncClient::LoadMaxSeqsData(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  LoadMaxSeqsData(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper StoreServiceAsyncClient::recv_wrapped_LoadMaxSeqsData( ::seqsvr::MaxSeqsData& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_LoadMaxSeqsDataT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_LoadMaxSeqsDataT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StoreServiceAsyncClient::recv_LoadMaxSeqsData( ::seqsvr::MaxSeqsData& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_LoadMaxSeqsData(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StoreServiceAsyncClient::recv_instance_LoadMaxSeqsData( ::seqsvr::MaxSeqsData& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_LoadMaxSeqsData(_return, state);
}

folly::exception_wrapper StoreServiceAsyncClient::recv_instance_wrapped_LoadMaxSeqsData( ::seqsvr::MaxSeqsData& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_LoadMaxSeqsData(_return, state);
}

void StoreServiceAsyncClient::SaveMaxSeq(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t id, int64_t max_seq) {
  ::apache::thrift::RpcOptions rpcOptions;
  SaveMaxSeqImpl(false, rpcOptions, std::move(callback), id, max_seq);
}

void StoreServiceAsyncClient::SaveMaxSeq(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t id, int64_t max_seq) {
  SaveMaxSeqImpl(false, rpcOptions, std::move(callback), id, max_seq);
}

void StoreServiceAsyncClient::SaveMaxSeqImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t id, int64_t max_seq) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      SaveMaxSeqT(&writer, useSync, rpcOptions, std::move(callback), id, max_seq);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      SaveMaxSeqT(&writer, useSync, rpcOptions, std::move(callback), id, max_seq);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

int64_t StoreServiceAsyncClient::sync_SaveMaxSeq(int32_t id, int64_t max_seq) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_SaveMaxSeq(rpcOptions, id, max_seq);
}

int64_t StoreServiceAsyncClient::sync_SaveMaxSeq(apache::thrift::RpcOptions& rpcOptions, int32_t id, int64_t max_seq) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  SaveMaxSeqImpl(true, rpcOptions, std::move(callback), id, max_seq);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_SaveMaxSeq(_returnState);
}

folly::Future<int64_t> StoreServiceAsyncClient::future_SaveMaxSeq(int32_t id, int64_t max_seq) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_SaveMaxSeq(rpcOptions, id, max_seq);
}

folly::Future<int64_t> StoreServiceAsyncClient::future_SaveMaxSeq(apache::thrift::RpcOptions& rpcOptions, int32_t id, int64_t max_seq) {
  folly::Promise<int64_t> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<int64_t>>(std::move(_promise), recv_wrapped_SaveMaxSeq, channel_);
  SaveMaxSeq(rpcOptions, std::move(callback), id, max_seq);
  return _future;
}

folly::Future<std::pair<int64_t, std::unique_ptr<apache::thrift::transport::THeader>>> StoreServiceAsyncClient::header_future_SaveMaxSeq(apache::thrift::RpcOptions& rpcOptions, int32_t id, int64_t max_seq) {
  folly::Promise<std::pair<int64_t, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<int64_t>>(std::move(_promise), recv_wrapped_SaveMaxSeq, channel_);
  SaveMaxSeq(rpcOptions, std::move(callback), id, max_seq);
  return _future;
}

void StoreServiceAsyncClient::SaveMaxSeq(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t id, int64_t max_seq) {
  SaveMaxSeq(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), id, max_seq);
}

folly::exception_wrapper StoreServiceAsyncClient::recv_wrapped_SaveMaxSeq(int64_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_SaveMaxSeqT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_SaveMaxSeqT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int64_t StoreServiceAsyncClient::recv_SaveMaxSeq(::apache::thrift::ClientReceiveState& state) {
  int64_t _return;
  auto ew = recv_wrapped_SaveMaxSeq(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

int64_t StoreServiceAsyncClient::recv_instance_SaveMaxSeq(::apache::thrift::ClientReceiveState& state) {
  return recv_SaveMaxSeq(state);
}

folly::exception_wrapper StoreServiceAsyncClient::recv_instance_wrapped_SaveMaxSeq(int64_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_SaveMaxSeq(_return, state);
}

void StoreServiceAsyncClient::LoadRouteTable(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  LoadRouteTableImpl(false, rpcOptions, std::move(callback));
}

void StoreServiceAsyncClient::LoadRouteTable(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  LoadRouteTableImpl(false, rpcOptions, std::move(callback));
}

void StoreServiceAsyncClient::LoadRouteTableImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      LoadRouteTableT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      LoadRouteTableT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void StoreServiceAsyncClient::sync_LoadRouteTable( ::seqsvr::Router& _return) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_LoadRouteTable(rpcOptions, _return);
}

void StoreServiceAsyncClient::sync_LoadRouteTable(apache::thrift::RpcOptions& rpcOptions,  ::seqsvr::Router& _return) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  LoadRouteTableImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_LoadRouteTable(_return, _returnState);
}

folly::Future< ::seqsvr::Router> StoreServiceAsyncClient::future_LoadRouteTable() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_LoadRouteTable(rpcOptions);
}

folly::Future< ::seqsvr::Router> StoreServiceAsyncClient::future_LoadRouteTable(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise< ::seqsvr::Router> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::seqsvr::Router>>(std::move(_promise), recv_wrapped_LoadRouteTable, channel_);
  LoadRouteTable(rpcOptions, std::move(callback));
  return _future;
}

folly::Future<std::pair< ::seqsvr::Router, std::unique_ptr<apache::thrift::transport::THeader>>> StoreServiceAsyncClient::header_future_LoadRouteTable(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair< ::seqsvr::Router, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::seqsvr::Router>>(std::move(_promise), recv_wrapped_LoadRouteTable, channel_);
  LoadRouteTable(rpcOptions, std::move(callback));
  return _future;
}

void StoreServiceAsyncClient::LoadRouteTable(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  LoadRouteTable(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper StoreServiceAsyncClient::recv_wrapped_LoadRouteTable( ::seqsvr::Router& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_LoadRouteTableT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_LoadRouteTableT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void StoreServiceAsyncClient::recv_LoadRouteTable( ::seqsvr::Router& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_LoadRouteTable(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void StoreServiceAsyncClient::recv_instance_LoadRouteTable( ::seqsvr::Router& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_LoadRouteTable(_return, state);
}

folly::exception_wrapper StoreServiceAsyncClient::recv_instance_wrapped_LoadRouteTable( ::seqsvr::Router& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_LoadRouteTable(_return, state);
}

void StoreServiceAsyncClient::SaveRouteTable(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::seqsvr::Router& router) {
  ::apache::thrift::RpcOptions rpcOptions;
  SaveRouteTableImpl(false, rpcOptions, std::move(callback), router);
}

void StoreServiceAsyncClient::SaveRouteTable(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::seqsvr::Router& router) {
  SaveRouteTableImpl(false, rpcOptions, std::move(callback), router);
}

void StoreServiceAsyncClient::SaveRouteTableImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::seqsvr::Router& router) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      SaveRouteTableT(&writer, useSync, rpcOptions, std::move(callback), router);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      SaveRouteTableT(&writer, useSync, rpcOptions, std::move(callback), router);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

bool StoreServiceAsyncClient::sync_SaveRouteTable(const  ::seqsvr::Router& router) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_SaveRouteTable(rpcOptions, router);
}

bool StoreServiceAsyncClient::sync_SaveRouteTable(apache::thrift::RpcOptions& rpcOptions, const  ::seqsvr::Router& router) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  SaveRouteTableImpl(true, rpcOptions, std::move(callback), router);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_SaveRouteTable(_returnState);
}

folly::Future<bool> StoreServiceAsyncClient::future_SaveRouteTable(const  ::seqsvr::Router& router) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_SaveRouteTable(rpcOptions, router);
}

folly::Future<bool> StoreServiceAsyncClient::future_SaveRouteTable(apache::thrift::RpcOptions& rpcOptions, const  ::seqsvr::Router& router) {
  folly::Promise<bool> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<bool>>(std::move(_promise), recv_wrapped_SaveRouteTable, channel_);
  SaveRouteTable(rpcOptions, std::move(callback), router);
  return _future;
}

folly::Future<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> StoreServiceAsyncClient::header_future_SaveRouteTable(apache::thrift::RpcOptions& rpcOptions, const  ::seqsvr::Router& router) {
  folly::Promise<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<bool>>(std::move(_promise), recv_wrapped_SaveRouteTable, channel_);
  SaveRouteTable(rpcOptions, std::move(callback), router);
  return _future;
}

void StoreServiceAsyncClient::SaveRouteTable(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::seqsvr::Router& router) {
  SaveRouteTable(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), router);
}

folly::exception_wrapper StoreServiceAsyncClient::recv_wrapped_SaveRouteTable(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_SaveRouteTableT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_SaveRouteTableT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

bool StoreServiceAsyncClient::recv_SaveRouteTable(::apache::thrift::ClientReceiveState& state) {
  bool _return;
  auto ew = recv_wrapped_SaveRouteTable(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

bool StoreServiceAsyncClient::recv_instance_SaveRouteTable(::apache::thrift::ClientReceiveState& state) {
  return recv_SaveRouteTable(state);
}

folly::exception_wrapper StoreServiceAsyncClient::recv_instance_wrapped_SaveRouteTable(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_SaveRouteTable(_return, state);
}

} // seqsvr
namespace apache { namespace thrift {

}} // apache::thrift
